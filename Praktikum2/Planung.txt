		Verteilte GGT-Berechnung

	Übersicht

Das System soll den GGT von n Zahlen auf n verschiedenen GGT-Prozessen bestimmen und 
dabei von einem Starter gestartet und einem Koordinator koordiniert werden. Dabei soll
es für mehrere GGT-Berechnungen zur Verfügung stehen ohne, dass die beteiligten
Komponenten neu gestartet werden müssen.
Das System soll aus vier wesentlichen Komponenten bestehen:

Den GGT-Prozessen die die Berechnung des GGT bewerkstelligen.
Den Starter-Prozessen die jeweils einen Teil der GGT-Prozesse starten.
Ein Koordinator der sowohl das hoch- und runterfahren des Systems, als auch die Berechnung
des GGTs überwacht.
Ein Namensdienst der PIDs Namen zuordnet.


	Systemphasen

Initialisierungsphase:
Zunächst werden Namensdienst und  Koordinator gestartet.
Daraufhin werden die Starter gestartet und erfragen beim Koordinator die steuernden 
Werte für die GGT-Prozesse ab. Die Starter starten dann mit den übermittelten Werten
die GGT-Prozesse um sich dann von alleine zu beenden.
Die GGT-Prozesse registrieren sich nun beim Namensdienst mit der Nachricht "rebind" und
beim Koordinator mit der Nachricht "hello".
Der Koordinator mischt die Prozesse nun, ordnet sie in einem zufälligen Ring an und informiert sie
mit der Nachricht "setneighbors" über ihren linken und rechten Nachbarn.

Arbeitsphase:
Der Koordinator informiert jeden GGT-Prozess über seinen Startwert "mi" mit der Nachricht
"setpm".
Wenn alle GGT-Prozesse ihren Startwert bekommen haben schickt der Koordinator an 15% der
GGT-Prozesse (mindestens 2) eine Nachricht "sendy" um die GGT-Berechnung zu starten.
Immer wenn sich nun der "mi" eines GGT-Prozesses ändert, informiert er den Koordinator
mit der Nachricht "briefmi" darüber und schickt eine Nachricht "sendy" mit dem neuen Wert
an seinen linken und rechten Nachbarn.
Wenn nun einer der GGT-Prozesse für "max_wait_time" Millisekunden keine Nachricht bekommt, 
startet er eine Terminierungsabstimmung. Dazu schickt er eine Nachricht "abstimmung" mit 
seinem eigenen registrierten Namen an seinen rechten Nachbarn. Wenn sein Nachbar 
"max_wait-time" / 2 Millisekunden gewartet hat schickt er diese Nachricht weiter. Kommt
diese Nachricht beim ursprünglichen Versender wieder an, gilt die Berechnung als
beendet und er schickt das Endergebnis der Berechnung mit der Nachricht "briefterm" an
den Koordinator.

Beendigungsphase:
Der Koordinator schickt an jeden GGT-Prozess eine Nachricht "kill". Die GGT-Prozesse
melden sich dann unverzüglich vom Namensdienst mit einer Nachricht "unbind" ab und 
terminieren dann.

Koordinator
	Allgemein(Aufgaben, hier vielleicht ein wenig doppelt durch deine Beschreibung oben aber ich fand es zur schnellen Übersicht ganz gut es als Liste nochmal dazuzuschreiben)
		-Überwacht das ganze System und gibt mittels einer Textausgabe dem Benutzer
			die Möglichkeit zur Übersicht.
		-Fährt die anderen Systeme (Starter) hoch
		-Startet die Berechnung
		-bezieht steuernde Werte aus der koordinator.cfg
			- Erlang Node des Namensdienstes
			- Anzahl der ggT-Prozesse pro Starter
			- simulierte Berechnungszeit der ggT-Prozesse (Verzögerungszeit in Mlls)
			- Terminierungszeit (in Mlls)
		- nimmt Nachrichten von Startern und ggT-Prozessen entgegen
			Zustand "initial":
				Starter:
				- Anfrage des Starters <PID>
				+ Antwort: Anzahl der zu startenden <Anzahl, Verzögerungszeit, Terminierungszeit>
				+ Log: Starter <PID> Angemeldet 
			
				ggT-Prozess:
				-meldet sich an <PID, Nachricht "hello" Infos über den Prozess, was auch immer da interesant ist>
				+ Antwort: <Anmeldung Erfolgreich>
				+ Log: PID- ggT-Prozess angemeldet <Timestamp>
				
			Zustand "bereit":(wird manuell erzeugt)
				- Anfrage des Starters <PID>
				+ Antwort: <rejected>
				+ Log : Starter: <PID> rejected
				
				ggT-Prozess:
				- meldet sich an <PID, Nachricht "hello" Infos über den Prozess, was auch immer da interesant ist>
				+ Antwort: <rejected>
				+ Log : ggT-Prozess: <PID> rejected
				
				+ Ring aufbauen <Nachricht "setneighbors", PID linkerNachbar, PID rechterNachbar>
				
				+ ggT Berechnung initialisieren: <Nachricht "setpm", Startwert> (wie berechnet sich der Startwert? Koordinator Punkt 6 verwirrt mich berifft auch das "sendy" Punkt 7)
				+ an 15% um Berechnung zu starten <Nachricht "sendy", berechneterWert>
				
				- mi des Prozesses ändert sich <PID ,Nachricht "briefmi">
				+ Log: Mi des ggT-Prozesses <PID> ändert sich.
				
				- Terminierung der ggT-Prozesse <PID ,Nachricht "briefterm", endWert>
				+ Log: ggT-Prozess <PID> beendet die Berechnung. Ergebnis <endWert>
				+ Wenn Berechnung nicht stimmt Log: berechneter Wert <endWert> stimmte nicht richtig wäre <kleinsterTeiler>
				+ Wenn Flag gesetzt: <Nachticht "sendy", kleinsterTeiler	>
							
				Konsole
				- Prüfwert angeben <gewünschter_ggT>
				- terminieren <TerminierungsBefehl>
				
			Zustand "beenden"
			
				ggT-Prozess:
				+ beenden <Nachricht "kill">
	Log
		StartNachricht
		Starter gestartet
	
Starter
	Allegemeines 
		- startet die ggT-Prozesse
	Log
	
ggT Prozesse
	Allgemeines
		- berechnet ggT mittels des Satzes von Euklid
	Nachrichten
		Arbeitsphase:
		Koordinator:
		+ mi ändert sich <PID ,Nachricht "briefmi">
		
		linker Nachbar:
		+ mi ändert sich <PID, Nachricht "sendy", neuerMIWert>
		
		rechter Nachbar:
		+ mi ändert sich <PID, Nachricht "sendy", neuerMIWert>
	Log

